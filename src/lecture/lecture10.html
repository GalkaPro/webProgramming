<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Web-programming Lecture 10 React Introduction</title>
    <link href="https://fonts.googleapis.com/css?family=Comfortaa:400,700|Orbitron:400,700,800&display=swap" rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="../../css/style.css">
</head>
<body>
<header class="header-lecture">
    <a class="title-lecture"><span>Лекция 10</span>Основы React.js</a>
    <a href="../../index.html" class="link-btn">&lArr; Главная</a>
</header>
<a href="#" title="Вверх" class="btn-top">Вверх</a>
<section class="lecture-content">
    <h3>React - JavaScript-библиотека для создания пользовательских интерфейсов</h3>
    <h4>Основные особенности создания приложений на React.js</h4>
    <p class="subtitle">Декларативный подход к описанию интерфейсов</p>
    <p>
        React-разработка заключается в описании того, что нужно вывести на страницу (а не в составлении инструкций для
        браузера, посвящённых тому, как это делать). Это, кроме прочего, означает значительное сокращение объёмов шаблонного кода.
    </p>
    <p>
        В React, приступая к разработке, просто начинают писать код. Тут нет шаблонного кода компонентов, который нужно
        как-то генерировать. Конечно, перед разработкой нужна некоторая подготовка, но, когда дело доходит до
        компонентов, их можно описывать в виде чистых функций.
    </p>
    <p class="subtitle">Чёткий синтаксис</p>
    <p>
        В React применяется синтаксис JSX, который воспринимается как обычный HTML, то есть, для того, чтобы приступить
        к React-разработке, не нужно изучать принципиально новые вещи.
    </p>
    <p class="subtitle">Правильная кривая обучения</p>
    <p>
        Кривая обучения — это важный фактор, который нужно учитывать при выборе UI-фреймворка. В этой связи надо отметить,
        что зная JavaScript, можно научиться писать React-приложения буквально за день. Конечно, для того, чтобы научиться
        делать это правильно, потребуется некоторое время, но приступить к работе можно очень и очень быстро.
    </p>
    <p class="subtitle">Особенности механизма привязки данных</p>
    <p>
        В React используется односторонняя привязка данных. Это — большой плюс данной библиотеки, так как выражается
        это в том, что программист всегда точно знает о том, что привело к изменению состояния приложения. Подобный
        подход к привязке данных значительно упрощает отладку приложений.
    </p>
    <p class="subtitle">Функциональный подход к разработке</p>
    <p>
        Одной из сильнейших сторон React является тот факт, что эта библиотека не принуждает разработчика к использованию
        классов. В React все компоненты пользовательского интерфейса могут быть выражены в виде наборов чистых функций.
        Использование чистых функций для формирования UI позволяет избежать чрезмерного усложнения кода.
    </p>
    <h3>Создание нового React-приложения</h3>
    <h4>Рекомендуемый набор инструментов </h4>
    <ul>
        <li>Для изучения React или создания нового одностраничного приложения необходимо использовать Create React App.</li>
        <li>Для создания серверного сайта с Node.js используется Next.js.</li>
        <li>При создании статического контент-ориентированного сайта удобно использовать Gatsby.</li>
    </ul>
    <p class="subtitle">Create React App </p>
    <p>
        Create React App — удобная среда для изучения React и лучший способ начать создание нового одностраничного приложения на React.
    </p>
    <p>
        Инструмент настраивает среду для использования новейших возможностей JavaScript, оптимизирует приложение для
        продакшена и обеспечивает комфорт во время разработки. Для разработки понадобятся Node.js не ниже версии 8.10 и
        npm не ниже версии 5.6. Для создания проекта необходимо выполнить следующие команды:
    </p>
    <pre><code>
        npx create-react-app my-app
        cd my-app
        npm start
    </code></pre>
    <div class="rules">
        <h4>Примечание</h4>
        <p>npx в первой строке не является опечаткой. Это инструмент запуска пакетов, доступный в версиях npm 5.2 и выше.</p>
    </div>
    <p>
        Create React App не обрабатывает бэкенд логику или базы данных, он только предоставляет команды для сборки
        фронтенда, поэтому возможно его использовать с любым бэкэндом. «Под капотом» используются Babel и webpack.
    </p>
    <p>
        Когда приложение готово к развёртыванию в продакшене, запуск команды</p>
    <pre><code>npm run build</code></pre>
    <p>создаст оптимизированную сборку приложения в папке build. Вы можете узнать больше о Create React App <a href="https://github.com/facebook/create-react-app#create-react-app--">из его README.</a></p>
    <p class="subtitle">Next.js </p>
    <p>
        Next.js - это популярный легковесный фреймворк для статических и серверных приложений, использующих React. Он включает в
        себя готовые решения для стилизации и маршрутизации и предполагает, что вы используете Node.js в качестве серверной среды.
    </p>
    <p class="subtitle">Gatsby</p>
    <p>
        Gatsby - лучший способ для создания статических сайтов с помощью React. Он позволяет использовать React-компоненты, но
        выводит предварительно отрендеренный HTML и CSS, чтобы гарантировать минимальное время загрузки.
    </p>
    <p class="subtitle">Создание набора инструментов с нуля </p>
    <p>
        В набор инструментов для сборки JavaScript обычно входят:
    </p>
    <ul>
        <li>
            Менеджер пакетов, такой как Yarn или npm. Он позволяет использовать обширную экосистему сторонних
            пакетов и легко устанавливать или обновлять их.
        </li>
        <li>
            Сборщик, такой как webpack или Parcel. Он позволяет писать модульный код и объединять его в небольшие пакеты,
            чтобы оптимизировать время загрузки.
        </li>
        <li>
            Компилятор, такой как Babel. Он позволяет писать современный код JavaScript, который будет работать даже в старых браузерах.
        </li>
    </ul>
    <p>
        При создании собственного набора JavaScript-инструментов с нуля нужно учитывать необходимость настройки созданного
        набора для продакшена.
    </p>
    <h3>Основные понятия</h3>
    <h4>Знакомство с JSX</h4>
    <p>
        JSX — это синтаксическое расширение JavaScript, которое позволяет создавать компоненты, используя возможности HTML и JavaScript.
    </p>
    <pre><code>const element = &lt;h1>Привет, мир!&lt;/h1>;</code></pre>
    <p>JSX производит «элементы» React.</p>
    <p>
        React исходит из принципа, что логика рендеринга неразрывно связана с прочей логикой UI: с тем, как
        обрабатываются события, как состояние изменяется во времени и как данные готовятся к отображению.
    </p>
    <p>
        Вместо того, чтобы искусственно разделить технологии, помещая разметку и логику в разные файлы, React разделяет
        ответственность с помощью слабо связанных единиц, называемых «компоненты», которые содержат и разметку, и логику.
    </p>
    <pre>
        <code>
            const name = 'Иван-Царевич';
            const element = &lt;h1>Здравствуй, {name}!&lt;/h1>;

            ReactDOM.render(
              element,
              document.getElementById('root')
            );
        </code>
    </pre>
    <p>
        В этом примере мы объявляем переменную name и затем используем её внутри JSX, обрамляя фигурными скобками.
        JSX допускает использование любых корректных JavaScript-выражений внутри фигурных скобок. Например, 2 + 2,
        user.firstName и formatName(user) являются допустимыми выражениями.
    </p>
    <p>
        В примере ниже мы встраиваем результат вызова JavaScript-функции formatName(user) в элемент &lt;h1>:
    </p>
    <pre>
        <code>
            function formatName(user) {
              return user.firstName + ' ' + user.lastName;
            }

            const user = {
              firstName: 'Марья',
              lastName: 'Моревна'
            };

            const element = (
              &lt;h1>
                Здравствуй, {formatName(user)}!
              &lt;/h1>
            );

            ReactDOM.render(
              element,
              document.getElementById('root')
            );
        </code>
    </pre>
    <p>
        JSX это тоже выражение. После компиляции каждое JSX-выражение становится обычным вызовом JavaScript-функции,
        результат которого — объект JavaScript. Из этого следует, что JSX можно использовать внутри выражений if и
        циклов for, присваивать переменным, передавать функции в качестве аргумента и возвращать из функции.
    </p>
    <pre>
        <code>
            function getGreeting(user) {
              if (user) {
                return &lt;h1>Здравствуй, {formatName(user)}!&lt;/h1>;
              }
              return &lt;h1>Здравствуй, незнакомец.&lt;/h1>;
            }
        </code>
    </pre>
    <h4>Использование атрибутов JSX</h4>
    <p>
        Чтобы использовать строковый литерал в качестве атрибута, используются кавычки:
    </p>
    <pre><code>const element = &lt;div tabIndex="0">&lt;/div>;</code></pre>
    <p>
        Если же в атрибут требуется указать JavaScript-выражение, то на помощь приходят фигурные скобки:
    </p>
    <pre><code>const element = &lt;img src={user.avatarUrl}>&lt;/img>;</code></pre>
    <p>
        Когда используется JavaScript-выражение в атрибуте, вокруг фигурных скобок кавычки не ставятся. Следует либо
        применить кавычки (для строковых литералов), либо фигурные скобки (для выражений), но не то и другое вместе.
    </p>
    <p>
        Поскольку JSX ближе к JavaScript чем к HTML, React DOM использует стиль именования camelCase для свойств вместо обычных имён HTML-атрибутов.
    </p>
    <p>
        Например, class становится className в JSX, а tabindex становится tabIndex.
    </p>
    <p>Если тег пуст, то его можно сразу же закрыть с помощью /> точно так же, как и в XML:</p>
    <pre><code>const element = &lt;img src={user.avatarUrl} />;</code></pre>
    <p>
        Но JSX-теги могут и содержать дочерние элементы:
    </p>
    <pre>
        <code>
            const element = (
              &lt;div>
                &lt;h1>Здравствуйте!&lt;/h1>
                &lt;h2>Рады вас видеть.&lt;/h2>
              &lt;/div>
            );
        </code>
    </pre>
    <p>
        JSX представляет собой объекты. Babel компилирует JSX в вызовы React.createElement(). Эти объекты называются
        React-элементами. Можно сказать, что они описывают результат, который мы хотим увидеть на экране. React
        читает эти объекты и использует их, чтобы конструировать и поддерживать DOM.
    </p>
    <h4>Элементы — мельчайшие кирпичики React-приложений.</h4>
    <p>
        Элемент описывает то, что вы хотите увидеть на экране:
    </p>
    <pre><code>const element = &lt;h1>Привет, мир!&lt;/h1>;</code></pre>
    <p>
        В отличие от DOM-элементов, элементы React — это простые объекты, не отнимающие много ресурсов. React DOM
        обновляет DOM, чтобы он соответствовал переданным React-элементам.
    </p>
    <div class="rules">
        <h4>Примечание</h4>
        <p>
            Элементы можно перепутать с более известной концепцией «компонентов». Элементы — это то, «из чего сделаны» компоненты.
        </p>
    </div>
    <h4>Рендеринг элемента в DOM</h4>
    <p>Допустим, в вашем HTML-файле есть &lt;div>:</p>
    <pre><code>&lt;div id="root">&lt;/div></code></pre>
    <p>Мы назовём его «корневым» узлом DOM, так как React DOM будет управлять его содержимым. </p>
    <p>
        Обычно в приложениях, написанных полностью на React, есть только один корневой элемент. При встраивании React в
        существующее приложение вы можете рендерить в столько независимых корневых элементов, сколько посчитаете нужным.
    </p>
    <p>
        Для рендеринга React-элемента в корневой узел DOM, вызовите ReactDOM.render() с React-элементом и корневым DOM узлом в качестве аргументов:
    </p>
    <pre>
        <code>
        const element = &lt;h1>Hello, world&lt;/h1>;
        ReactDOM.render(element, document.getElementById('root'));
        </code>
    </pre>
    <p>На странице будет написано «Hello, world».</p>
    <h4>Обновление элементов на странице </h4>
    <p>
        Элементы React иммутабельны. После создания элемента, нельзя изменить его потомков или атрибуты. Элемент похож
        на кадр в фильме: он отражает состояние интерфейса в конкретный момент времени.
    </p>
    <p>
        Пока что, мы знаем только один способ обновить интерфейс — это создать новый элемент и передать его
        в ReactDOM.render(). Рассмотрим пример с часами:
    </p>
    <pre>
        <code>
        function tick() {
          const element = (
            &lt;div>
              &lt;h1>Hello, world!&lt;/h1>
              &lt;h2>It is {new Date().toLocaleTimeString()}.&lt;/h2>
            &lt;/div>
          );
          ReactDOM.render(element, document.getElementById('root'));
        }
        setInterval(tick, 1000);
        </code>
    </pre>
    <p>В этом примере ReactDOM.render() вызывается каждую секунду с помощью колбэка setInterval().</p>
    <p>
        React DOM сравнивает элемент и его дочернее дерево с предыдущей версией и вносит в DOM только минимально необходимые
        изменения. Несмотря на то, что мы создаём элемент, описывающий всё UI-дерево, каждую секунду React DOM изменяет
        только текстовый узел, содержимое которого изменилось.
    </p>
    <div class="rules">
        <h4>Примечание</h4>
        <p>
            На практике большинство React-приложений вызывают ReactDOM.render() только один раз. Далее
            вы узнаете, как можно обновлять интерфейс при помощи компонента с состоянием.
        </p>
    </div>
    <h3>Компоненты и пропсы</h3>
    <p>
        Компоненты позволяют разбить интерфейс на независимые части, про которые легко думать в отдельности. Их можно
        складывать вместе и использовать несколько раз. Во многом компоненты ведут себя как обычные функции JavaScript.
        Они принимают произвольные входные данные (так называемые «пропсы») и возвращают React-элементы, описывающие,
        что мы хотим увидеть на экране.
    </p>
    <h4>Функциональные и классовые компоненты</h4>
    <p>Проще всего объявить React-компонент как функцию:</p>
    <pre>
        <code>
            function Welcome(props) {
              return &lt;h1>Привет, {props.name}&lt;/h1>;
            }
        </code>
    </pre>
    <p>
        Эта функция — компонент, потому что она получает данные в одном объекте («пропсы») в качестве параметра и
        возвращает React-элемент. Мы будем называть такие компоненты «функциональными», так как они буквально являются функциями.
    </p>
    <p>Ещё компоненты можно определять как классы:</p>
    <pre>
        <code>
            class Welcome extends React.Component {
              render() {
                return &lt;h1>Привет, {this.props.name}&lt;/h1>;
              }
            }
        </code>
    </pre>
    <p>С точки зрения React, эти два компонента эквивалентны. Функциональным и классовым компонентам доступны
        дополнительные возможности, о которых мы поговорим далее.</p>
    <p>Пока что мы только встречали React-элементы, представляющие собой DOM-теги:</p>
    <pre><code>const element = &lt;div />;</code></pre>
    <p>Но элементы могут описывать и наши собственные компоненты:</p>
    <pre><code>const element = &lt;Welcome name="Алиса" />;</code></pre>
    <p>Когда React встречает подобный элемент, он собирает все JSX-атрибуты и дочерние элементы в один объект и передаёт
        их нашему компоненту. Этот объект называется «пропсы» (props).</p>
    <p>Например, этот компонент выведет «Привет, Алиса» на страницу:</p>
    <pre>
        <code>
            function Welcome(props) {
              return &lt;h1>Привет, {props.name}&lt;/h1>;
            }

            const element = &lt;Welcome name="Алиса" />;
            ReactDOM.render(
              element,
              document.getElementById('root')
            );
        </code>
    </pre>
    <p>Давайте разберём, что именно здесь происходит:</p>
    <ol>
        <li>Мы передаём React-элемент &lt;Welcome name="Алиса" /> в ReactDOM.render().</li>
        <li>React вызывает наш компонент Welcome с пропсами {name: 'Алиса'}.</li>
        <li>Наш компонент Welcome возвращает элемент &lt;h1>Привет, Алиса&lt;/h1> в качестве результата.</li>
        <li>React DOM делает минимальные изменения в DOM, чтобы получилось &lt;h1>Привет, Алиса&lt;/h1>.</li>
    </ol>
    <div class="rules">
        <h4>Примечание: Всегда называйте компоненты с заглавной буквы.</h4>
        <p>
            Если компонент начинается с маленькой буквы, React принимает его за DOM-тег. Например, &lt;div /> это div-тег
        из HTML, а &lt;Welcome /> это уже наш компонент Welcome, который должен быть в области видимости.
        </p>
    </div>
    <h4>Композиция компонентов</h4>
    <p>
        Компоненты могут ссылаться на другие компоненты в возвращённом ими дереве. Это позволяет нам использовать одну
        и ту же абстракцию — компоненты — на любом уровне нашего приложения. Неважно, пишем ли мы кнопку, форму или
        целый экран: все они, как правило, представляют собой компоненты в React-приложениях.
    </p>
    <p>
        Например, компонент App может отрендерить компонент Welcome несколько раз:
    </p>
    <pre>
        <code>
            function Welcome(props) {
              return &lt;h1>Привет, {props.name}&lt;/h1>;
            }

            function App() {
              return (
                &lt;div>
                  &lt;Welcome name="Алиса" />
                  &lt;Welcome name="Базилио" />
                  &lt;Welcome name="Буратино" />
                &lt;/div>
              );
            }

            ReactDOM.render(
              &lt;App />,
              document.getElementById('root')
            );
        </code>
    </pre>
    <p>
        В приложениях, написанных на React с нуля, как правило, есть один компонент App, который находится на самом
        верху. В случае, если вы переписываете существующее приложение на React, имеет смысл начать работу с
        маленького компонента типа Button и постепенно двигаться «вверх» по иерархии.
    </p>
    <h4>Извлечение компонентов</h4>
    <p>
        Не бойтесь разбивать компоненты на части. Допустим, у нас есть компонент Comment:
    </p>
    <pre>
        <code>
            function Comment(props) {
              return (
                &lt;div className="Comment">
                  &lt;div className="UserInfo">
                    &lt;img className="Avatar"
                         src={props.author.avatarUrl}
                         alt={props.author.name}
                    />
                    &lt;div className="UserInfo-name">
                      {props.author.name}
                    &lt;/div>
                  &lt;/div>
                  &lt;div className="Comment-text">
                    {props.text}
                  &lt;/div>
                  &lt;div className="Comment-date">
                    {formatDate(props.date)}
                  &lt;/div>
                &lt;/div>
              );
            }
        </code>
    </pre>
    <p>
        Этот компонент представляет собой комментарий в социальной сети. Его пропсы включают в себя author (объект),
        text (строка), и date (дата). С этим компонентом может быть не очень удобно работать из-за излишней вложенности.
        Мы также не можем повторно использовать его составные части. Давайте извлечём из него пару компонентов.
    </p>
    <p>
        Для начала извлечём Avatar:
    </p>
    <pre>
        <code>
            function Avatar(props) {
              return (
                &lt;img className="Avatar"
                     src={props.user.avatarUrl}
                     alt={props.user.name}
                />
              );
            }
        </code>
    </pre>
    <p>
        Компоненту Avatar незачем знать, что он рендерится внутри Comment. Поэтому мы дали его пропcу чуть менее конкретное
        имя — user, а не author. Пропсы следует называть так, чтобы они имели смысл в первую очередь с точки зрения самого
        компонента, а уже во вторую тех компонентов, которые его рендерят.
    </p>
    <p>Теперь можно немножко упростить наш Comment:</p>
    <pre>
        <code>
            function Comment(props) {
              return (
                &lt;div className="Comment">
                  &lt;div className="UserInfo">
                    &lt;Avatar user={props.author} />
                    &lt;div className="UserInfo-name">
                      {props.author.name}
                    &lt;/div>
                  &lt;/div>
                  &lt;div className="Comment-text">
                    {props.text}
                  &lt;/div>
                  &lt;div className="Comment-date">
                    {formatDate(props.date)}
                  &lt;/div>
                &lt;/div>
              );
            }
        </code>
    </pre>
    <p>Следующим шагом извлечём компонент UserInfo, который рендерит Avatar рядом с именем пользователя:</p>
    <pre>
        <code>
            function UserInfo(props) {
              return (
                &lt;div className="UserInfo">
                  &lt;Avatar user={props.user} />
                  &lt;div className="UserInfo-name">
                    {props.user.name}
                  &lt;/div>
                &lt;/div>
              );
            }
        </code>
    </pre>
    <p>Это позволит ещё сильнее упростить Comment:</p>
    <pre>
        <code>
            function Comment(props) {
              return (
                &lt;div className="Comment">
                  &lt;UserInfo user={props.author} />
                  &lt;div className="Comment-text">
                    {props.text}
                  &lt;/div>
                  &lt;div className="Comment-date">
                    {formatDate(props.date)}
                  &lt;/div>
                &lt;/div>
              );
            }
        </code>
    </pre>
    <p>
        Извлечение компонентов может сначала показаться неблагодарной работой. Тем не менее, в больших приложениях
        очень полезно иметь палитру компонентов, которые можно многократно использовать. Если вы не уверены,
        извлекать компонент или нет, вот простое правило. Если какая-то часть интерфейса многократно в нём
        повторяется (Button, Panel, Avatar) или сама по себе достаточно сложная (App, FeedStory, Comment), имеет
        смысл её вынести в независимый компонент.
    </p>
    <h4>Пропсы можно только читать</h4>
    <p>
        Компонент никогда не должен что-то записывать в свои пропсы — вне зависимости от того, функциональный он или
        классовый. Возьмём для примера функцию sum:
    </p>
    <pre>
        <code>
            function sum(a, b) {
              return a + b;
            }
        </code>
    </pre>
    <p>
        Такие функции называют «чистыми», потому что они не меняют свои входные данные и предсказуемо возвращают
        один и тот же результат для одинаковых аргументов.
    </p>
    <p>
        А вот пример нечистой функции — она записывает данные в свои же аргументы:
    </p>
    <pre>
        <code>
            function withdraw(account, amount) {
              account.total -= amount;
            }
        </code>
    </pre>
    <p>React достаточно гибкий, но есть одно правило, которое нельзя нарушать:</p>
    <p><strong>React-компоненты обязаны вести себя как чистые функции по отношению к своим пропсам.</strong></p>
    <p>
        Конечно, интерфейсы приложений обычно изменяются с течением времени. На следующей лекции мы узнаем о том,
        что такое «состояние» компонента. Состояние даёт компонентам возможность реагировать на действия пользователя,
        ответы сервера и другие события, не нарушая чистоту компонента.
    </p>

</section>
<div class="btn-next-previous">
    <a class="btn-previous" href="lecture9.html" target="_parent"><span class="uppercase">Лекция 9. </span> <span class="bold">Основы JavaScript.</span></a>
    <a class="btn-next" href="lecture11.html"><span class="uppercase">Лекция 11. </span><span class="bold">Компоненты и события в React.js</span></a>
</div>
<footer>
    <div class="footer-logo">
        <img src="../../image/white_red_svg_with_undertext.svg" alt="logo">
    </div>
    <div class="name footer-outline">
        <p>Проскура Галина Анатольевна, к.т.н., доцент каф. 504</p>
    </div>
    <div class="links">
        <a class="footer-social-link" href="skype:galka.proskura?chat">
            <div class="footer-social-icon"><img src="../../image/skype.svg" alt="skype" class="footer-social-image"></div>
            <span class="footer-social-title">Skype</span>
        </a>
        <a class="footer-social-link" href="mailto:g.proskura@khai.edu">
            <div class="footer-social-icon"><img src="../../image/email-icon.svg" alt="email" class="footer-social-image"></div>
            <span class="footer-social-title">g.proskura@khai.edu</span>
        </a>

    </div>
</footer>

</body>
</html>